//args[0] = target
var target = args[0];

//ensures scripts exist on target server
scp("hack.script", "home", target);
scp("grow.script", "home", target);
scp("weak.script", "home", target);

var cSec = getServerSecurityLevel(target);
var minSec = getServerMinSecurityLevel(target);
//security delta per thread
var glvl;
var wlvl;
var hlvl;
//time per script. may change per run. based on hacking lvl
var gtime;
var wtime;
var htime;
var longest;
//Ram per script
var gRam = getScriptRam("grow.script", target);
var wRam = getScriptRam("weak.script", target);
var hRam = getScriptRam("hack.script", target);
//const time difference
var tdif = 250;
//target ram
var servRam = getServerMaxRam("home") - getServerUsedRam("home");
var gMaxT = Math.floor(servRam / gRam);
var wMaxT = Math.floor(servRam / wRam);
var hMaxT = Math.floor(servRam / hRam);


while (true) {
	//calculate GWH security inc/dec per thread
	glvl = growthAnalyzeSecurity(1);
	wlvl = weakenAnalyze(1);
	w2lvl = weakenAnalyze(1, 2);
	hlvl = hackAnalyzeSecurity(1);

	//calculate GWH time in ms on target
	gtime = getGrowTime(args[0]);
	wtime = getWeakenTime(args[0]);
	htime = getHackTime(args[0]);
	//sets how many times hack can be run during weaken if hack fails.
	print("grow time: " + gtime);
	print("weaken time: " + wtime);
	print("hack time: " + htime);

	//checks if server is at minSec. weakens until at minSec. should only need to be run on new servers
	print("Running Initial Weaken");
	print("Minimum Security Level: " + minSec);
	print("weaken 1 thread, 1 core: " + wlvl);
	print("weaken 1 thread, 2 core: " + w2lvl);

	//calculate percent inc needed to get to max money
	var cMon = getServerMoneyAvailable(target);
	var maxMon = getServerMaxMoney(target);
	var monPer = maxMon / cMon;
	var tMon;
	var t2Mon;
	var gSecInc;
	var g2SecInc;
	//
	if (cMon != maxMon) {
		//number of thread needed to get to maxMon
		tMon = growthAnalyze("home", monPer, 1);
		t2Mon = growthAnalyze("home", monPer, 2);
		//security inc of max grow
		gSecInc = growthAnalyzeSecurity(tMon);
		g2SecInc = growthAnalyzeSecurity(t2Mon);
	}
	else {
		tMon = 0;
		t2Mon = 0;
		gSecInc = 0;
		g2SecInc = 0;
	}
	//security inc of max grow
	//threads needed to weaken back to min. one additional thread to account for decimal issues
	var wThrDec = (cSec - minSec + gSecInc) / wlvl + 1;
	var w2ThrDec = (cSec - minSec + g2SecInc) / w2lvl + 1;
	var gSleep = wtime - tdif - gtime;

	//will set server to minSec and Max Money
	// trys to run scripts until ram is available if not immediately 
	//var running = false;
	print(hackAnalyze(target));
	print("1 core -  Grow: " + nFormat((tMon * gRam) * Math.pow(1024, 3), "0.00b") +
		" Weak: " + nFormat((wThrDec * wRam) * Math.pow(1024, 3), "0.00b"));
	print("2 core -  Grow: " + nFormat((t2Mon * gRam) * Math.pow(1024, 3), "0.00b") +
		" Weak: " + nFormat((w2ThrDec * wRam) * Math.pow(1024, 3), "0.00b"));
	//exit();
	//var gMaxT = (getServerMaxRam("home") - getServerUsedRam("home")) / gRam;
	//var wMaxT = (getServerMaxRam("home") - getServerUsedRam("home")) / wRam;

	var gRun = Math.ceil((t2Mon * gRam) / (getServerMaxRam("home") - getServerUsedRam("home")));
	var wRun = Math.ceil((w2ThrDec * wRam) / (getServerMaxRam("home") - getServerUsedRam("home")));

	/* if (cMon != maxMon) {
		for (i = 0; i < gRun; i++) {
			if (i != gRun - 1) {
				while (isRunning("grow.script", "home", [target, "0"])) {
					sleep(tdif);
				}
				exec("grow.script", "home", gMaxT, target, 0);
				sleep(gtime + tdif);
			}
			else {
				while (isRunning("grow.script", "home", [target, "0"])) {
					sleep(tdif);
				}
				exec("grow.script", "home", t2Mon - (gMaxT * i), target, 0);
				sleep(gtime + tdif);
			}
		}
		cMon = getServerMoneyAvailable(target);

	}
	if (cSec != minSec) {
		for (i = 0; i < wRun; i++) {
			if (i != wRun - 1) {
				while (isRunning("weak.script", "home", [target])) {
					sleep(tdif);
				}
				exec("weak.script", "home", wMaxT, target);
				sleep(wtime + tdif);
			}
			else {
				while (isRunning("weak.script", "home", [target])) {
					sleep(tdif);
				}
				exec("weak.script", "home", w2ThrDec - (wMaxT * i), target);
				sleep(wtime + tdif);
			}
		}
		cSec = getServerSecurityLevel(target);
	} */



	/* while (cSec != minSec) {
		var thrs = (cSec - minSec) / wlvl;
		if (thrs >= wMaxT) {
			exec("weak.script", target, wMaxT, target);
			sleep(wtime);
		}
		else {
			exec("weak.script", target, thrs + 1, target);
			sleep(wtime);
		}

		print("Minimum Security Level: " + minSec);
		cSec = getServerSecurityLevel(target);
	} */
	print("Target Primed");
	print("Current Money: " + cMon);
	print("Max Money: " + maxMon);
	print("Current Security: " + cSec);
	print("Minimum Security: " + minSec);
	//target will now be at min security lvl

	//calculate threads per script
	var w1;
	var w2;
	var g;
	var h;

	function recursiveWThread(low, high, tot, ghlvl) {
		var mid = Math.ceil(((high - low) / 2) + low);
		//var equH = minSec + ((tot - high) * ghlvl) - (high * w2lvl);
		//var equL = minSec + ((tot - low) * ghlvl) - (low * w2lvl);
		var equM = minSec + ((tot - mid) * ghlvl) - (mid * w2lvl);
		//sleep(60000);
		//if (prompt("Continue")) {
		/* if (minSec >= equH && equH > minSec - w2lvl) {
			return high;
		}
		if (minSec >= equL && equL > minSec - w2lvl) {
			return low;
		} */
		if (minSec >= equM && equM > minSec - w2lvl) {
			return mid;
		}
		else if (equM >= minSec - w2lvl) {
			return recursiveWThread(mid, high, tot, ghlvl);
		}
		else {
			return recursiveWThread(low, mid, tot, ghlvl);
		}
		//}
	}
	var w1 = 1;
	var w2 = 1;
	var g = gMaxT - 1;
	var h = hMaxT - 1;
	/* print("Threads Calculating Itr...")

	while (minSec + (g * glvl) - (w1 * w2lvl) > minSec && g != w1) {
		w1++;
		g--;
	}
	while (minSec + (h * hlvl) - (w2 * w2lvl) > minSec && h != w2) {
		w2++;
		h--;
	}
	print("Threads Calculated Itr!!")
	print("W1 threads Itr: " + w1);
	print("W2 threads Itr: " + w2);
	print("G threads Itr: " + g);
	print("H threads Itr: " + h); */
	print("Threads Calculating recursively...")
	//var date = Date().getSeconds();
	var start = new Date().getSeconds();
	print(start);
	var w1 = recursiveWThread(0, gMaxT, wMaxT, glvl);
	var w2 = recursiveWThread(0, hMaxT, wMaxT, hlvl);
	var end = new Date().getSeconds();
	print(end);
	var g = gMaxT - w1;
	var h = hMaxT - w2;
	print("Threads Calculated recursively")
	print("Time: " + (end - start));
	print("W1 threads recursive: " + w1);
	print("W2 threads recursive: " + w2);
	print("G threads recursive: " + g);
	print("H threads recursive: " + h);
	exit();


	//print("Threads: Grow - " + g + ", Weak1 - " + w1 + ", Hack - " + h + ", Weak2 - " + w2);
	//run scripts with time dif as args for hack and grow
	//cycle is grow/weak -> hack/weak
	//calculates time grow and hack need to sleep to finish before weaken
	//var gSleep = wtime - tdif - gtime;
	var hSuccess = 0;
	var i = 0;
	//sets how many times hack can be run during weaken if hack fails.
	hMaxTime = Math.floor(wtime / (htime + 1000));
	print("Time per cycle: " + tFormat(wtime * 2));
	print("Starting Grow Phase...");

	exec("grow.script", "home", g, target, gSleep);
	exec("weak.script", "home", w1, target);

	sleep(wtime + tdif);
	print("Grow Phase Finished");
	print("Starting Hack Phase...");

	exec("weak.script", "home", w2, target);
	do {
		exec("hack.script", "home", h, target);
		sleep(htime);
		//scp("hack-" + target + ".txt", "home", getHostname());
		hSuccess = Number(read("hack-" + target + ".txt"));
		if (hSuccess != 0) { print("Successful Hack: " + hSuccess); }
		i++;
	}
	while (hSuccess == 0 && i <= hMaxTime);
	if (i != hMaxTime) {
		sleep((wtime + tdif) - htime * i);
	}
	print("Hack Phase Finished")
}
